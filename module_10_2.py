#  Цель: научиться создавать классы наследованные от класса Thread.
#  Задача "За честь и отвагу!":


import threading  # Импортируем модуль для работы с потоками
import time  # Импортируем модуль для создания задержки


class Knight(threading.Thread):
    """
    Класс Knight (Рыцарь), наследуемый от класса Thread.
    Этот класс описывает рыцаря, который будет сражаться с врагами в отдельном потоке.

    Атрибуты:
    ----------
    name : str
        Имя рыцаря.
    power : int
        Сила удара рыцаря (сколько врагов он побеждает за один "день").
    days : int
        Количество дней, сколько рыцарь сражается.
    enemies : int
        Количество врагов, с которыми сражается рыцарь (всегда 100).

    Методы:
    -------
    run():
        Метод, который запускается при старте потока. Он описывает логику сражения рыцаря с врагами.
    """

    def __init__(self, name, power):
        """
        Инициализатор класса Knight (конструктор).

        Параметры:
        ----------
        name : str
            Имя рыцаря.
        power : int
            Сила рыцаря, определяющая, сколько врагов он побеждает за один день.
        """
        super().__init__()  # Вызываем конструктор базового класса Thread
        self.name = name  # Устанавливаем имя рыцаря
        self.power = power  # Устанавливаем силу рыцаря
        self.days = 0  # Количество дней сражения, начинаем с 0
        self.enemies = 100  # Изначально у каждого рыцаря 100 врагов

    def run(self):
        """
        Метод run() содержит основную логику сражения рыцаря.
        Этот метод будет запущен при старте потока.
        """
        print(f"{self.name}, на нас напали!")  # Сообщаем о начале сражения

        # Цикл продолжается, пока есть враги
        while self.enemies > 0:
            time.sleep(1)  # Задержка в 1 секунду, чтобы имитировать один "день" сражения
            self.days += 1  # Увеличиваем количество дней
            self.enemies -= self.power  # Уменьшаем количество врагов на силу рыцаря

            # Важно: количество врагов не должно стать отрицательным
            remaining_enemies = max(0, self.enemies)

            # Выводим информацию о текущем дне сражения и количестве оставшихся врагов
            print(f"{self.name}, сражается {self.days} день(дня)..., осталось {remaining_enemies} воинов.")

        # Если враги закончились, выводим сообщение о победе рыцаря
        print(f"{self.name} одержал победу спустя {self.days} дней(дня)!")


# --- Основная часть программы ---

# Создаем объекты рыцарей
first_knight = Knight('Sir Lancelot', 10)  # Первый рыцарь: Сэр Ланселот, сила 10
second_knight = Knight("Sir Galahad", 20)  # Второй рыцарь: Сэр Галаад, сила 20

# Запуск потоков (рыцари начинают сражение)
first_knight.start()  # Запускаем поток для первого рыцаря
second_knight.start()  # Запускаем поток для второго рыцаря

# Метод join() нужен для того, чтобы главный поток программы
# дождался завершения потоков рыцарей.
first_knight.join()  # Ожидаем завершения сражения первого рыцаря
second_knight.join()  # Ожидаем завершения сражения второго рыцаря

# Когда оба рыцаря завершили сражение, выводим сообщение
print("Все битвы закончились!")
